// The pipe example

typedef H = rec t.( ref N + ref C + ( ref [] => ref [] ; t ) )
typedef T = ref [] => ( (ref N ) + ( ref C ) ); none
typedef C = [ close : [] ]
typedef N = [ element : int , next : ref H ]

typedef Pipe = [ flag : ref [] , start_ptr : ref H , end_ptr : ref T ]
typedef Writer = [ end_ptr : ref T ]
typedef Reader = [ flag : ref [] , start_ptr : ref H ]
typedef CloseWriter = [ end_ptr : none ]
typedef ClosedReader = [ flag : ref boolean , start_ptr : none ]

typedef MakePipe = () -> Pipe
typedef Put = ( int >> none , Writer >> Writer ) -> none
typedef Close = Writer >> CloseWriter -> none
typedef TryTake = Reader >> ClosedReader -> int + []

;;
// actual code follows

let makePipe() =
	let node : H * T = new {} in
		let head : H = node in
			{ flag  = new {} , start_ptr = new head, end_ptr = new node }
		end
	end
	in

let put( e, p ) : Put =
	let n : H * T = new {} in
		borrow field : ref T = p.end_ptr in
			let s : T = !field in
				focus s;
				s := { element = e , next = n };
				defocus s;
				field := n
			end
		end
	end
	in
	
let close( p ) : Close =
	let cell : ref T = p.end_ptr in // intentionally destructive field read
		let last : T = !cell in
			delete cell;
			focus last;
			last := { closed = {} };
			defocus last
		end
	end
	in

let tryTake( c ) : TryTake =
	borrow field : ref H = c.start_ptr in
		let head : H = !field in
			focus head;
			case head of
				ref [] -> defocus head; {}
			|	ref [ closed: [] ] -> // end of pipe, pipe closed
					delete head;
					delete field;
					borrow flag = c.flag in flag := true end;
					{} // no result
			|	ref [ element : E , next : H ] -> // has element, then unique
					let node = !head in
						delete head;
						field := node.next;
						node.element
					end
			end
		end
	end
	in

	// now some client code:

	let takeAll( reader ) : ( Reader >> none ) -> none =
		tryTake( reader ); // ignores output
		case reader of
			ClosedReader -> {} // closed, done
		|	Reader -> takeAll( reader ) // not closed
		end
		in
	
		let pipe : Reader * Writer = makePipe() in
			let reader : Reader = pipe in
				let writer : Writer = pipe in
					put( writer , 1 );
					put( writer , 2 );
					close( writer );
					takeAll ( reader )
					// both pipe components have been exhausted
				end
			end
		end

	end

end end end end
/* label location just like records label elements of a pair. */

// I'll try to specify both the shorter and longer versions to make it clear how they are related.
typedef Node = all t.( fresh n.( [ elem : int , next : t+n ] :: ( n : ref Node[t] ) ) )
typedef Node = all tail.( [ elem : int , next : ref Node[tail] + tail ] )

typedef Tail =  fresh n.( [ elem : int , next : n ] :: ( n : ref [] ) )
typedef Tail = [ elem : int , next : ref [] ]

// note that each node must be individually allocated
typedef Empty = fresh h,t.( [ head : h , tail : t ] :: ( h : ref [] ) :: ( t : ref [] ) )
typedef Empty = [ head : ref [] , tail : ref [] ]

typedef Single = fresh n.( [ head : ref n , tail : ref n ] :: ( n : ref Tail ) )
typedef Single = fresh h,t,n.( [ head : h , tail : t ] :: ( h : ref n ) :: ( t : ref n ) :: ( n : ref Tail )

typedef List = fresh t.( [ head : ref (ref Node[t])  , tail : ref ( t : ref Tail ) ] )

typedef Insert = "x:Single -> x:List"
	all h,t,n.(
		[ head : h , tail : t ] :: ( h : ref n ) :: ( t : ref n ) :: ( n : ref Tail )
		-> fresh nh.( none :: ( h : ref nh ) :: ( nh : ref n ) :: ( t : ref n ) :: ( n : ref Tail ) )
		// this can be packed to a List as (note it hides the 'new head' location):
			( none :: ( h : ref Node[n] ) :: ( t : ref n ) :: ( n : ref Tail ) )
	)

	// define these types...
	// structure
	// capability
	SList[h,t] = all h,t. [ head : h , tail : t ]
	Single[h,t,n] = all h,t,n. ( h : ref n ) :: ( t : ref n ) :: ( n : ref Tail )
	List[h,t,n] =  ( h : ref Node[n] ) :: ( t : ref n ) :: ( n : ref Tail )
	
	// implicitly freshes h,t,n
	SList[h,t] :: Single[h,t,n] -> :: List[h,t,n]
	
	// actually, it should only need the head...
	all h,t,n.(
		[ head : ref n ]
		-> fresh nh.( none :: ( h : ref nh ) :: ( nh : ref n ) )
		// this can be packed (by hiding the new location):
			none :: ( h : ref Node[n] )
	)

		[ head : ref [] , tail : ref []  ] -> none :: ( head : ref Node[n] )
		[ head : ref n ] -> none :: ( head : ref ( ref Node[n] ) )

// functions

def makeList : () -> Empty 
let makeList = func().{ head = new {} , tail = new {} }

def makeNode : ( int ) $->$ [ elem : int , next : ref [] ]
let makeNode = func( i ).{ elem = i , next = new {} }

$\red{ FIXME not require head on last 2, relation between list and result list }$
// convenient notation to push fresh out?
// more of an all use than fresh...
def insert : ( int , Empty ) $->$ none :: Single
					& ( int , Single ) $->$ none :: List
					& ( int , List ) $->$ none :: List
let insert = func( i , list ).
	let tail = !list.tail in
		// if the list is empty, then the tail is []
		// otherwise the tail contains the last node of the list
		case tail of
			[] -> // if tail is empty, the head must also be empty
					// i.e. list : Empty is the only type that satisfies
					let n = new makeNode(i) in
						list.tail := n ;
						list.head := n // note both point to same new node
					end
			ref Tail -> // tail not empty, just set next and move tail pointer
				tail.next := new makeNode(e) ;
				list.tail := tail.next
		end
	end // note it only returns capabilities, not (usable) values
\end{lstlisting}

\begin{lstlisting}[float=*,numbers=none]
$\red{same type problems as above.}$
def remove = Empty $->$ [] :: Empty
					& Single $->$ int :: Empty
					& List $->$ int :: Single + List 	// should only require tail! note that we let it become imprecise
					// alternatively could return a testable result such as:
					& List $->$ ( int , [] ) :: Single + ( int , boolean ) :: List
					// perhaps add a "test" function to inspect his imprecise state?
let remove = func( list ). // list may be empty
	let head = !list.head in
		case head of
			[] -> {} // empty list
			ref Node -> // else, i.e. has element
					let i = !head.elem in
						list.head := !(!head.next) ;
						delete head;
						case !list.head of
							[] -> // list is empty
								list.tail := {} ;
								list.head := {}
							Tail -> // list : Single
							Node -> // list : List
						end ;
/* We would need to return a different value for each case (Single,List) for clients to be able to distinguish since the
capabilities is not present at run-time. However, we do not need to carry such imprecision "forever" as inserting
will move the list from Single+List to List for sure! We must have that: if A+B and A$->$C & B$->$C then C */
						i
					end
			end
	end
	
def inspect = ( Empty $->$ boolean::Empty ) & ( Single -> int :: Single ) & ( List -> [] :: List )
let inspect = func( list ).
	case list.head ...
	end
/* if we have list : Single+List then inspect( list ) will give us ( ( int :: Single ) + ( [] :: List ) ) */
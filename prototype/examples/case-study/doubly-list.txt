// doubly linked list node specification
let makeDNode = func(e).
 // the two are meant to be private (cannot be referenced from outer scopes)
 let next = new {} in
  let prev = new {} in
   let element = e in
    { getNext = func(). !next , // requires exposing internal type to make the state changes ``visible''
      getPrev = func(). !prev ,
      setNext = func(n). next := n ,
      setPrev = func(p). prev := p ,
      getElem = func(). e }
      // also note that the state can only mutate using these functions, thus its state changes are limited to what there functions allow.
   end
  end
 end

let makeDList = func().
 // private state of the structure
 let head = new {} in
  let tail = new {} in
		{ enqueue = func(e).
					let n = makeDNode(e) in
						case !head of
							[] -> // head is empty (thus, tail is too)
								head := n ;
								tail := n
							_ -> // not empty case
								(!head).setPrev( n ) ;
								n.setNext( !head ) ;
								head := n // new head is the appended node
						end
					end ,
			dequeue = func().
					case !tail of
						[] -> {} // empty list, nothing to return
						_ -> // has elements, return last and move tail
							let e = (!tail).getElem() in
								tail := (!tail).getPrev() ;
								case !tail of
									[] -> // if prev is unit, then list must be empty
										tail := {} ;
										head := {}
									_ -> // else list has element, no change needed
								end ;
								e
							end
					end }		
  end
 end
let makeTree = func(). { root = new {} }

let tryInsert = func( tree , e ).
	// creates the new node
	let node : U = { elem = e, kind = new {},
		left = new {}, right = new {} } in
			borrow root = tree.root in
				addToCell( root , node )
				focus root;
				case root of
					ro S -> // still in the stack
					ro V -> // already visited but not yet unique
					ref U -> // uniqueness was restored
						borrow kind = tree.kind in
							kind := TreeKind; // is unique tree
						end
				end
			end
		end
	end
	
	let addToCell = func( cell , n ).
	focus cell; // uses focus, although not all cases will require it
	case cell of
		ref [] -> // if empty, then must be unique
			cell := n;
			true // success!
		ro SM -> // shared node
			// iteration is happening on the left child
			borrow node = !cell in
				if( node.elem == n.elem )
					false // already in
				else
					if( node.elem < n.elem )
						// we needed to go right, insertion failed
						// (we don't even have access to the right child)
						defocus cell;
						{} // returns failure flag
					else
						// we need to go left, continue to try inserting
						let res = borrow left = node.left in
								addToCell( left , n )
								end
							in
								defocus cell;
								res
						end
					end
				end
			end

		ref U -> addToCellAux( node , cell );
					
		ro VM -> // node was already visited
			let res = addToCellAux( node , cell ) in
				defocus cell;
				res
			end
			
	end
	
let addToCellAux = func( node , cell ).
	borrow node = !cell in
		if( node.elem == n.elem )
			false // already in
		else
			if( node.elem < n.elem )
				borrow right = node.right in
					addToCell( right , n )
				end
			else
				borrow left = node.left in
					addToCell( left , n )
				end
			end
		end
	end
	in
	
	
	let makeStack = func(). { head = new {} }

let push = func( il , stack ).
	borrow head = stack.head in
		let n = { elem = il , next = new !head } in
			head := n
		end
	end

let pop = func( stack ).
	borrow head = stack.head in
		let h = !head in
			head := h.next;
			h.elem
		end
	end
	
	typedef TMP = // temporary typed used just for focused initialization
	U@=>[ kind : ref S_tag, left : none*MS*IV, right : ref U + [] ]
	// note the defocused type can legally be broken down into all the aliases
	// that are required in order to satisfy the access pattern spec.

let pushLefts = func( node , stack ).
	borrow tmp : IS * MS * (TMP; IV)= !node in
		// focused initialization of shared state
		// note that focus is held during the whole initialization
		borrow n : IS * (TMP;IV)= tmp in
			let it : IS = n in
				n.kind := S; // "in stack" tag
				// 'it' is not actually at IS, but focus is kept while inconsistent
				push( stack , it ); // IS alias is pushed into stack
				// we have two remaining for node: MS * IV
				
				borrow left = n.left in // inspect left node
					// remember that we are non-shared on its children
					case left of
						ref [] -> // no next left, done	
						ref U -> // has another left node
							// left is of type unique
							pushLefts( left , stack );
							// left : MS * IV
							// left branch is still ready to be aliased
					end
				end;
				// by defocusing while "left : MS * IV " we enable it to
				// be split by the access pattern so that each alias of it
				// sees a different use on that field
				defocus n
			end
		end
	end // borrowed argument has MS * IV type
	
	
	let iterator = func( tree ). // tree.root must be unique and nonempty
	let st = makeStack() in
		borrow rt = tree.root in 
			tree.kind := MutableTag;
			pushLefts( rt , st );
			{ stack = st , root = rt }
		end
	end
	
	let next = func( it ). // stack must not be empty
	borrow stack = it.stack in
		let current = pop( stack ) in
			focus current; // is 'S' type
			borrow right = current.right in
				case right of
					U -> // has right node
						// all uniques under this node
						pushLefts( right , stack );
						// nodes are place with 'P' type
						// have access pattern to children
					[] -> // does not have right
				end
			end
		
			current.kind := V; // visited
			
			borrow left = current.left in
				clean( left )
			end
			
			let result = current.elem in
				defocus current; // proper defocus at visited (V) type
	
				case stack of
					Empty ->
						let root = it.root in
							focus root;
							// only rights need cleaning
							clean( root );
							tree.kind := TreeTag
							defocus root;
						end
					Stack -> // OK to continue normally
						// tree not yet unique fully unique
				end;
				
				result
			end
		end
	end
	
	
	let clean = func( node )
	focus node;
	case node of
		ro V -> // 'visited'
			borrow n = !node in
				n.kind := U;
				borrow right = n.right in
					clean( right )
					// uses borrowing to move each right subtree to unique
				end
			end;
			defocus node
		ro S -> // type implies node still in stack!? bug.
			abort	// or else loop forever as the pattern allows
		ref [] -> // no child
	end
	// node ''consumed'' its pattern
	in
	
	// client code
	
	let iterateUntilDone = func( it ).
	case it of
		Iterator -> print( next( it ) );
			iterateUntilDone( it )
		Done -> // complete
	end
	in
	let tree = makeTree() in
		tryInsert( tree, 6 );	
		tryInsert( tree, 1 );
		tryInsert( tree, 4 );
		// the tree is unique, which means it will remain
		// a Tree and tryInsert returns booleans
	
		let it = iterator( tree ) in
			// tree is now shared
			tryInsert( tree , 8 ); // ignores results but may return []
			// tree is either Mutator or Tree
			
			tryInsert( tree , 2 ); // works on both cases...
			
			print( next( it ) );
			case it of
				Iterator -> // has more
					tryInsert( tree , 3 ); // still may fail to insert
					iterateUntilDone( it ); // makes sure iterator finishes
					
					tryInsert( tree , 5 ); // still may return []
					case tree of
						Tree -> // uniqueness restored
						Mutator -> // root still shared
					end
				Done -> //iteration is done
					// we still need to test the tree to be sure it returned to
					// unique, since we are using a "may interfere" we cannot
					// be sure it did so until we check.
			end
		end
	end
end

// Example of encoding a type similar to Behavioral Types
// but now using one level of indirection, through a this pointer, to avoid
// having to return a result with a 'res' and 'next' field.
// The resulting sequential behavior:
// setInt ; getInt ; dispose

// This is actually a more Plaid-like type since it does a "state change"
// to enable the next "behavior" of the object.

let newBehavior = fun( _ : [] ).
	open <this,ptr> = new {} in
    	// private state
        open <p,field> = new {} in
            let method = 
        	{ // list of methods from which the behavior will be made
    		 getInt = fun( _ : [] :: rw p int ).( !field ),
             setInt = fun( y : int :: rw p [] ).( field := y ),
             dispose = fun( _ : [] :: rw p int ).( delete field )
    		} in
                
                ptr := {
                	setInt = fun( i : int :: rw this []).
                		let val = (method.setInt i) in
                			ptr := {
                				getInt = fun( _ : [] :: rw this [] ).
                					let val = (method.getInt {} ) in
                						ptr := {
                							dispose = fun( _ : [] :: rw this [] ).
                								(method.dispose {})
                						};
                						val
                					end
                			};
                			val
                		end
                };
                
                // FIXME easier way to stack capabilities?
                // ... but subtyping, I may want to pack a more restrictive type?
                <this, ptr::rw this [ setInt:
					int :: rw this [] -o ![] :: rw this [ getInt:
						[] :: rw this [] -o !int :: rw this [ dispose: 
							[] :: rw this [] -o !int :: rw this [] ] ] ]>
            end
        end
    end
    in
    
	// client code that consumes the behavior
    open <t,x> = newBehavior {} in
        !x.setInt 0;
        !x.getInt {};
        !x.dispose {};
        delete x
    end
end
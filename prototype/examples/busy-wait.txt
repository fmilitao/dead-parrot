
// NOTE READY, just parser test.

typedef Retry = forall p.rec X.( ( rw p (Held#[]) => rw p (Held#[]) ; X )
	(+) ( rw p (Released#int) => none ) )

typedef OneUse = forall p.( rw p (Held#[]) => rw p (Released#int) )

open <u,meh> = new {} in

open <t,x> = new Held#{} in
	share t as (Retry[t]) || (OneUse[t]);

// FIXME: needs to be able to pick from multiple caps with same indexer...	
	meh := <(OneUse[t]):What,{}::(OneUse[t])>;
	
	fun Y(_:[]):int.( // FIXME argument and result are PLACE HOLDERS
		focus t;
		case !x of
			Held#n ->
				x := Held#n;
				defocus; // retry, did not consume shared type!
				Y {}// recursion point
		|	Released#n -> // recovers
				defocus;
				x := n; // FIXME + 1;
				// ...
				x := !x; // FIXME + 1;
				//...
				delete x
		end) {}
end

end
// this file introduces some idioms that we are using
// and that are not in the formalization

// multi-argument functions, through Currying
let f = fun(x : int, y : boolean ).x in
    // note the type of 'f' is "int -o boolean -o int"
    f 2 false
end;

let x = new false in
	0;
	open <t,y> = delete x in // I hate this delete rule...
		// or maybe it needs a proper subtyping for existentials and bang?
        y
    end
end;

// auto-stack of capabilities on last expression
// auto-pack to avoid error of having location vars.
// go out of scope.
open <p,x> = new 0 in
	0::rw p int; // manually stacking
    0::rw p _; // manually stacking with SPECIAL NAME
			// to mean any type that is in that capability.
	true // auto-stack and auto-pack.
	// on last element, try to pack:
	// < nloc , e :: all outstanding capabilities >

end
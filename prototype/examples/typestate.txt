let newObject = fun( _ : [] ).
	open <p,x>= new 0 in
		< p, // private location to be abstracted note that 'p' is never 
		// (directly) usable to client code because they lack a *reference* to it
		{
		 setBool = fun( y : boolean :: rw p int ). ( x := y ),
		 setInt = fun( y : int :: rw p boolean ).( x := y ),
		 getInt = fun( _ : [] :: rw p int ).( !x ),
		 getBool = fun( _ : [] :: rw p boolean ).( !x ),
		 dispose = fun( _ : [] :: rw p int ).( delete x )
		}::rw p int >
	end
	in
	
    // client code:
	open <t,obj> = newObject {} in
		obj.getInt {};
		obj.setBool false;
		obj.setInt 31337;
       	
		// we have to either destroy the object
		// or pass it as a result to the outside context
       	
		// a bit silly that dispose requires 'int' typestate
		obj.dispose {}
		//<t,obj::rw t int>
	end
end
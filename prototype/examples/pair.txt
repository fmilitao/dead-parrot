// Pair example + client code.

// In this version we just abstract the location variable.
// The 'typestate' example file abstracts the capability type, thus
// creating a proper typestate.

let newPair = fun( _ : [] ).
	open <pl,l> = new {} in
	open <pr,r> = new {} in
		{ // note that locations 'pl' and 'pr' are automatically packed
		// since otherwise they could not leave this scope.
			initL = fun( i : int :: rw pl [] ).( l := i ),
			initR = fun( i : int :: rw pr [] ).( r := i ),
			// FIXME needs basic addition, WAS !l+!r
			sum = fun( _ : [] :: ( rw pl int * rw pr int ) ). !l,
			destroy = fun ( _ : [] :: ( rw pl int * rw pr int ) ).( delete l; delete r ) 
		}
	end
	end
	in

	// client code
	open <l,tmp> = newPair({}) in
	open <r,x> = tmp in
		x.initL(12);
		x.initR(34);
		//x.sum({});
		// intentionally switch order for testing
		x.sum({}::(rw r int * rw l int));
		x.destroy({})
	end
	end

end
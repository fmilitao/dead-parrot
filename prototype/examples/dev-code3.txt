
// TODO: careful design examples...

// ALTERNATIVES

<p>fun( x : ref p :: rw p (A#int+B#boolean) ).
	case !x of
		A#i -> x := i
	|   B#b -> x := b
	end

/*

IMPORTANT EXAMPLES

each type may be: A * B * C (+) D * E, i.e. unstar may be necessary.

<p> fun( x : ref p :: ( rw p A#int (+) rw p B#boolean ) ).
// x : ref p ; rw p A#int (+) rw p B#boolean
		let y = 0 in
// x : ref p, y : int ; rw p A#int (+) rw p B#boolean
	// x : ref p, y : int , z = A#int ; rw p ![]
	// x : ref p, y : int , z = B#boolean ; rw p ![]
			let z = !x in
				z // : B#boolean + A#int 
	// x : ref p, y : int ; rw p ![]
	// x : ref p, y : int ; rw p ![]
			// FORCE JOIN @ end of scope for those that were created?
			end
		end
	// FORCE JOIN at end of function's scope.

Delta, A + B, C + D
Delta, A , C + D
	Delta, A, C --> Delta, A1, C1
	Delta, A, D --> Delta, A2, C2
		merged to: Delta, (A1 * C1) + (A2 * C2)
Delta, B, C + D
	Delta, B, C --> Delta, B1, C1
	Delta, B, D --> Delta, B2, D2
		merged to: Delta, (B1 * C1) + (B2 * D2)
		
=======================
		
		
<B><A><p>fun( x : ref p :: ( ( B * A * rw p (I#int)) (+) ( B * A * rw p (B#boolean)) ) ).
	!x

/*

// this just returns the same type
// RESULT: 
// forall p.( 
//		ref p :: ( rw p (I#int) (+) rw p (B#boolean) )
//	 -o ref p :: ( rw p (I#int) (+) rw p (B#boolean) ) )
<p>fun( x : ref p :: ( rw p (I#int) (+) rw p (B#boolean) ) ).
	x

;

// this should return a sum type
// forall p.( 
//		ref p :: ( rw p (I#int) (+) rw p (B#boolean) )
//	 -o I#int + B#boolean :: rw p ![] )
<p>fun( x : ref p :: ( rw p (I#int) (+) rw p (B#boolean) ) ).
	!x

;
	
// this should return an alternative
// forall p.( 
//		ref p :: rw p A#int+B#boolean )
//	 -o ![] :: ( rw p int (+) rw p boolean ) )
<p>fun( x : ref p :: rw p (A#int+B#boolean) ).
	case !x of
		A#i -> x := i
	|   B#b -> x := b
	end
*/

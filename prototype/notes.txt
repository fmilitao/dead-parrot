A * B * C
A (+) B (+) C
is seriously broken...

1. check returns { t : type, e : env }.
2. all returns just { t : * , e : env } // always the same environment
3. then immutable environments

BACKTRACK on alternatives.
	Whenever an attempt is made to read a capability that is inside an 
alternative it will throw an exception BackTrack(id,cause) that tells that it
requires unpacking that (+) type.
	Each check() has a try catch. If its environment has it packed, then attempt
if already unpacked, send it upwards.
	Attempt to merge, if fail throw exception that the backtrack should occur in
enclosing expression. If that fails too, and reaches top then all failed.

tryAlternative( ast, env ){
	try{
		return check( ast, env );
	}catch(e){
		if( e instanceof Backtrack ){
			// was already unpacked here... fail upwards
			if( env.get( id ).type() !== types.AlternativeType )
				throw e;
			
			// retry while unpacked
			var envs = env.unpack(id);
			var res = [];
			for(var i=0;i<envs.length;++i){
				res.push( tryAlternative( ast, envs[i] ) );
			}
			// attempt to merge
			if fail, then backtrack... again.
			
			return ...;
		}
		
		// not our cause, re-throw.
		throw e;
	}
}

if( env.get(id) === types.AlternativeType )
	// please unpack 'id' so that I can typecheck...
	throw new Backtrack(id, cause);

=========================================

IMPORTANT EXAMPLES

each type may be: A * B * C (+) D * E, i.e. unstar may be necessary.

<p> fun( x : ref p :: ( rw p A#int (+) rw p B#boolean ) ).
// x : ref p ; rw p A#int (+) rw p B#boolean
		let y = 0 in
// x : ref p, y : int ; rw p A#int (+) rw p B#boolean
	// x : ref p, y : int , z = A#int ; rw p ![]
	// x : ref p, y : int , z = B#boolean ; rw p ![]
			let z = !x in
				z // : B#boolean + A#int 
	// x : ref p, y : int ; rw p ![]
	// x : ref p, y : int ; rw p ![]
			// FORCE JOIN @ end of scope for those that were created?
			end
		end
	// FORCE JOIN at end of function's scope.

Delta, A + B, C + D
Delta, A , C + D
	Delta, A, C --> Delta, A1, C1
	Delta, A, D --> Delta, A2, C2
		merged to: Delta, (A1 * C1) + (A2 * C2)
Delta, B, C + D
	Delta, B, C --> Delta, B1, C1
	Delta, B, D --> Delta, B2, D2
		merged to: Delta, (B1 * C1) + (B2 * D2)

=========================================

REMEMBER:
 	- to disable chrome's cache
 	- launch 'static' on trunk/
 	
 	FIXME: recursive types on subtyping, equals and unAll may be infinite...
 	- IDIOT YOU ARE USING RECURSION WHEN WHILE IS ENOUGH...
 	
TODO:
	-- packing up to subtyping, instead of equals? list-adt example would
	be made slightly simpler, I guess.
	-- multi-open and multi-pack syntax sugar? use arrays of stuff
	open <a,b,c,d,x> = <p,q,X, ... >
	
=========================================

- location variables cannot be hidden, or renamed
- try to stack all "touched" capabilities at the end of a method.

- Typing algorithm:
	- name collisions should not be allowed, no crap about hidding.
(if the variable is hidden it may cause leaks)... renaming is
always possible anyway.

- check that OPEN does not produce a resulting environment/type that
depends on scoped types.
	
=========================================

LOW PRIORITY:
 - define when parentesis are needed in toHTML
 - define better parsing priorities to reduce use of parenthesis.
 	"fun( x ) . e := 2" should work directly, maybe?
 	might be messy to do with the share construct.

CODE STYLE:
 	--- ALWAYS USE IDENTITY === and !==
	- use 'instanceof' instead of has property 'ast' for errors
	+ use finally for exceptions?
	- CONSTANTS ARE CAPPED
	- console.debug for debug messages
	- console.error for error messages, it prints stack trace!
	- https://developers.google.com/chrome-developer-tools/docs/console

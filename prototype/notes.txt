BACKTRACK
	failed to read element
	failed to join early

 #1 ignore other alternatives (assume just 1)
REMOVE caps must consider alternatives?, kind of like an unstack?
 #2 consider others...
ALTERNATIVES

split (environment)
	- DELETE, ASSIGN, DEREF
	- STACK (including auto)
	causes splits

join (environment)

try-join (environment)
	// simplifies when all alternatives and types are already compatible


each type may be: A * B * C (+) D * E, i.e. unstar may be necessary.

<p> fun( x : ref p :: ( rw p A#int (+) rw p B#boolean ) ).
 // x : ref p ; rw p A#int (+) rw p B#boolean
		let y = 0 in
// x : ref p, y : int ; rw p A#int (+) rw p B#boolean
	// x : ref p, y : int , z = A#int ; rw p ![]
	// x : ref p, y : int , z = B#boolean ; rw p ![]
			let z = !x in
				z // : B#boolean + A#int 
	// x : ref p, y : int ; rw p ![]
	// x : ref p, y : int ; rw p ![]
			// FORCE JOIN @ end of scope for those that were created?
			end
		end
	// FORCE JOIN at end of function's scope.


=========================================

REMEMBER:
 	- to disable chrome's cache
 	- launch 'static' on trunk/
 	
 	FIXME: recursive types on subtyping, equals and unAll may be infinite...
 	- IDIOT YOU ARE USING RECURSION WHEN WHILE IS ENOUGH...
 	
TODO:
	-- packing up to subtyping, instead of equals? list-adt example would
	be made slightly simpler, I guess.
	-- multi-open and multi-pack syntax sugar? use arrays of stuff
	open <a,b,c,d,x> = <p,q,X, ... >
	
=========================================

- location variables cannot be hidden, or renamed
- try to stack all "touched" capabilities at the end of a method.

- Typing algorithm:
	- name collisions should not be allowed, no crap about hidding.
(if the variable is hidden it may cause leaks)... renaming is
always possible anyway.

- check that OPEN does not produce a resulting environment/type that
depends on scoped types.
	
=========================================

LOW PRIORITY:
 - define when parentesis are needed in toHTML
 - define better parsing priorities to reduce use of parenthesis.
 	"fun( x ) . e := 2" should work directly, maybe?
 	might be messy to do with the share construct.

CODE STYLE:
 	--- ALWAYS USE IDENTITY === and !==
	- use 'instanceof' instead of has property 'ast' for errors
	+ use finally for exceptions?
	- CONSTANTS ARE CAPPED
	- console.debug for debug messages
	- console.error for error messages, it prints stack trace!
	- https://developers.google.com/chrome-developer-tools/docs/console

// FIXME missing Delta^G restrictions on environments
// FIXME problem on priting multiple levels of capabilities
// FIXME is it possible to delete twice if at multiple levels??


		var importScript = function(file){
			$.ajax({ type : 'GET',
				async : false,
				url : file,
				dataType:'script',
				success : function(data) {}
			});
		};
		
ENVIRONMENT OPERATIONS:
 - focus( rely )
 	all behind a fake environment?
 	defocus, search for defocus cap and then restore it?
 - fake parent?
 
 - 3 FILTERS:

 # non-shared type 	
 	filter( t ){
 		// types that are sure to not interfere with any focused cell
 		return t.type === types.BangType ||
 			( t.type === types.ForallType && filter( t.inner().type ) ) ||
 			( t.type === types.ExistsType && filter( t.inner().type ) ) ||
 			( t.type === types.CapabilityType && filter( t.inner().type ) ||
 			( t.type === types.StackedType && filter( t.left().type ) && filter( t.right().type ) ); 
 	}
 	
 	// env on focus
 	defocus = new Environment(null,filter);
 	
 	function(t){
 		return this.$filter(t) && filter(t);
 	}
 	
 # \Delta^G
 	newScope(filterDefocus){
 		if( ... )
 		filters access to defocus
 	}
 	focus(t){
 		new Environment(null);
 		filter = shared_filter; // FLAGS?
 		parent = this.$parent; 
 		cap = [x...]
 		maps = {}
 	}
 	must hide defocus-guarantee, forbids defocus... but access to those filtered out should be possible.
 	
 - location
 	when adding a cap, must ensure hiding above filtering its repetition.
 	if( filter(type) ){
 	}
 	locations = { p : true }
 	
 	FILTER to parent environment


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
TRIAGE:
 - ensure no defocus guarantee on functions and forall abstraction
	DEFOCUS |> env
 - is duplication allowed?
 for caps it makes dereference messy since there are multiple to pick...
 but how to forbid it in a clean way?
 - isEquals on environments must be cleaned
 - join multiple typing environments with (+)
 - make sure packing an alternative cannot obey multiple alternatives
 simultaneously? is this important? such alternative cannot
 (logically) occur!
# clean up Environment code, it's currently messy.
# rethink collisions, specially with capabilities.


LOWER PRIORITY: 
 - organize error messages, as CONSTANTS?
 - pass assert function instead of 'ast'?
 - firefox issue with scrollbars (getScrollbarWidth function).
 - equals and subtypeOf functions must be cleaned they are messy... and buggy?

TODO?

# Notes on typing algorithm:
 - try to stack all "touched" capabilities at the end of a function.
 - check that OPEN does not produce a resulting environment/type that
 depends on scoped types.
 - packing up to subtyping, instead of equals?
 maybe allow manually to apply subtyping? (e : A)?
 list example would be made slightly simpler, maybe?

# ensure location variables cannot be hidden, or renamed.
	If the variable is hidden it may cause leaks, rename is always possible
	anyway...

# IDIOT YOU ARE USING RECURSION WHEN WHILE IS ENOUGH

# stacking alternatives:
 - other alternatives must be invalid, or there could be duplication of caps.
 - improve mergin so that differences are grouped in *-type and then (+). This
 	will then allow merging environments with different caps.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PENDING FIXES:

1. Capability visibility bug (?).
	The enclosing capability may become visible after the assumed capability is
	consumed.
	Not sure if this is actually unsound (need to look at proof and see wahy 
	such assumption was needed), or if it can be left there since it just
	creates a type that consumes a capability making it impossible to call such
	function (since the unique capability is no longer available).
	To show unsoundness test should typecheck but runtime abort due to deleting
	the same location twice (... is this even possible?).

	Attempt to write test case:
		open <t,x> = new 0 in
			let f = fun( _ : [] :: rw t int ).
				( delete x; delete x; 0 )
				// FIXME second delete should not be allowed?!
			in
				f {} // hmmm cannot call since capability was consumed by 'f'
			end
		end
	
2. Non-syntax directed alternative open.
	Currently the typechecker requires a "@p E" to know precisely where an
	alternative should be broken down into its separate bits. However, this is
	just a simplification since the typechecker could employ a search algorithm
	to check all possible different alternatives until finding one that checks
	such code. (this is decidable since there is a finite number of expressions
	and the alternatives also list a finite number of elements)

3. Define convenient parsing priorities (to recude use of parenthesis).
	This is needed, but boring, since it is not all that clear which changes
	will potentially cause conflicts in the grammar making this a try-fail
	change...
	Grammar should probably allow:
 		fun( x : ... ) . e := 2
 	to work directly? What are some convenient priorities?

4. Syntax sugar for multi-open?
	open < a, < b, < c , < d , x > > > > = x in ... end
	
===============================================================================

REMEMBER:
 	- to disable chrome's cache
 	- launch 'static' on trunk/

CODE STYLE:
 	--- ALWAYS USE IDENTITY === and !==
	- use 'instanceof' instead of has property 'ast' for errors
	+ use finally for exceptions?
	- CONSTANTS ARE CAPPED
	- console.debug for debug messages
	- console.error for error messages, it prints stack trace!
	- https://developers.google.com/chrome-developer-tools/docs/console
	- convention: "fake" protected/private fields using $NAME

// Copyright (C) 2013 Filipe Militao <filipe.militao@cs.cmu.edu>
// GPL v3 Licensed http://www.gnu.org/licenses/

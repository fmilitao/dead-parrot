WORKPLAN:

1. FIXME use concat... the code is quite messy without it.
why didn't I use concat from the start??

2. Define a convenient recursion
	HOW TO ADD A FRIENDLY CONSTRUCT FOR RECURSION?
	REC X.A is actually quite ugly...
	
3. Write tests.

======================

 - grammar (including pairs, typedef, recursion)
	* case, label
	* focus, defocus, share
	* recursion?
	* tuples
	* packs with convenient labeling 	
	* typedef
	
 - types:
 	* pair type
 	* recursive type
 	* tagged sum
 	* alternative -- tricky to typecheck?
 	* rely + guarantee

======================

IDIOMS:
-- on last element, try to pack:
	< nloc , e :: all outstanding capabilities >
-- currying for multi-argument functions

======================

-- how to throw exceptions from parse so that they look like JISON and check that records have no duplicated field names

-- location variables cannot be hidden, or renaming
- try to stack all "touched" capabilities at the end of a method.

- Typing algorithm:
	- name collisions should not be allowed, no crap about hidding.
(if the variable is hidden it may cause leaks)... renaming is
always possible anyway.

- check that OPEN does not produce a resulting environment/type that
depends on scoped types.

Types:
	- location variables
	- capability
	- reference
	- pure type
	- function type
	- forall type
	- exists type
	- none type??
	- record type
	- identifier/type var.
	- primitive type
	
========================================

>> define when parentesis are needed in toHTML for types?

+ use finally for exceptions?

- define standard Lib:
	+ - / *
	> < == !=
	&& || !

- define parsing priorities...
 fun( x ) . e := 2
	+ priorities, functions and sequence without ( x := 1 )

========================================

- code style:
	- CONSTANTS ARE CAPPED
	- console.debug for debug messages
	- console.error for error messages, it prints stack trace!
	- https://developers.google.com/chrome-developer-tools/docs/console
